{"version":3,"file":"bundle.js","mappings":";6LAAMA,EAAAA,WACF,WAAYC,EAAaC,gGAAkB,SACvCC,KAAKF,YAAcA,EAAYG,MAAM,IACrCD,KAAKD,iBAAmBA,EACxBC,KAAKE,YAAc,GACnBF,KAAKG,OAAS,SACjB,0CAED,WAAa,WACLC,EAAS,GAMb,OAJAJ,KAAKF,YAAYO,SAAQ,SAACC,GACtBF,GAAU,EAAKF,YAAYK,SAASD,EAAOE,gBAA6B,MAAXF,EAAiBA,EAAS,GAC1F,IAEMF,CACV,4BAED,WACI,MAAoB,aAAhBJ,KAAKG,OACE,sCAAP,OAA6CH,KAAKF,YAAYW,KAAK,IAAnE,KACqB,YAAhBT,KAAKG,OACH,uBAAP,OAA8BH,KAAKD,kBAE5B,oCAAP,OAA2CC,KAAKF,YAAYW,KAAK,IAAjE,IAEP,0BAED,SAAUC,GACNA,EAAYA,EAAUF,cACtB,IAAMG,GAAYX,KAAKE,YAAYK,SAASG,GACtCE,GAAcZ,KAAKF,YAAYS,SAASG,GAE1B,YAAhBV,KAAKG,SAGLQ,GACAX,KAAKE,YAAYW,KAAKH,EAAUF,eAEhCG,GAAYC,GACZZ,KAAKD,mBAGTC,KAAKc,kBAAkBd,KAAKF,YAAaE,KAAKD,iBAAkBC,KAAKE,aACxE,kCAED,WAAoB,IACZa,EADY,OAGc,IAA1Bf,KAAKD,iBACLC,KAAKG,OAAS,UAEdY,EAAgBf,KAAKF,YAAYkB,OAAM,SAACC,GACpC,OAAO,EAAKf,YAAYK,SAASU,EAAcT,gBAAoC,MAAlBS,CACpE,IACDjB,KAAKG,OAASY,EAAgB,WAAa,UAElD,4EAzDClB,sPCCN,m6MADA,IAAMqB,EAAS,gCAAG,WAAOC,GAAP,yFACSC,MAAM,2CAAD,OAA4CD,GAAa,CAAC,GADxE,UAGU,OAFlBE,EADQ,QAGDlB,OAHC,iCAISkB,EAASC,OAJlB,cAIJC,EAJI,yBAKHA,EAAKC,QALF,cAOJ,IAAIC,MAAM,8BAPN,0NAAH,ySCCf,8hGAAAC,GAAA,wBAAAA,EAAA,sBAAAA,GAAA,iBAAAA,GAAA,0oDAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,4bAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,yhBAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,qGAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,+XAEA,IAGIC,EAHEC,EAA0BC,SAASC,cAAc,sBACjDC,EAAaF,SAASC,cAAc,gBACpCE,EAAcH,SAASC,cAAc,SAG3CG,OAAOC,iBAAiB,YAAY,SAACC,GACjCR,EAAMS,UAAUD,EAAEE,KAClBC,GACH,IAED,IAAMA,EAAS,WACXP,EAAWQ,YAAcZ,EAAMxB,OAC/ByB,EAAwBW,YAAcZ,EAAMa,cAC5CR,EAAYS,UAAY,GAEJC,MAAMC,KAAKhB,EAAMH,QACvBnB,SAAQ,SAACC,GACnB,IAAMsC,EAAgBf,SAASgB,cAAc,QAC7CD,EAAcL,YAAcjC,EAC5B0B,EAAYc,OAAOF,EACtB,GACJ,EAEKG,EAAS,gCAAG,oGACO7B,EAAU,GADjB,OACRM,EADQ,OAEdG,EAAQ,IAAI9B,EAAQ2B,EAAQ,GAC5Bc,IAHc,yNAAH,qDAMfT,SAASC,cAAc,eAAeI,iBAAiB,QAASa,GAEhEA","sources":["webpack://boilerplate/./src/hangman.js","webpack://boilerplate/./src/http-requests-handler.js","webpack://boilerplate/./src/index.js"],"sourcesContent":["class Hangman {\n    constructor(correctWord, remainingGuesses) {\n        this.correctWord = correctWord.split('');\n        this.remainingGuesses = remainingGuesses;\n        this.guessesMade = [];\n        this.status = 'Playing';\n    }\n\n    get puzzle() {\n        let puzzel = '';\n\n        this.correctWord.forEach((letter) => {\n            puzzel += this.guessesMade.includes(letter.toLowerCase()) || letter === ' ' ? letter : '*';\n        });\n\n        return puzzel;\n    }\n\n    get statusMessage() {\n        if (this.status === 'Finished')\n            return `Great work, you guessed the word:  ${this.correctWord.join('')}!`;\n        else if (this.status === 'Playing')\n            return `Remaining guesses:  ${this.remainingGuesses}`;\n        else\n            return `Nice try, the correct word was:  ${this.correctWord.join('')}!`;\n\n    }\n\n    makeGuess(character) {\n        character = character.toLowerCase();\n        const isUnique = !this.guessesMade.includes(character);\n        const isBadGuess = !this.correctWord.includes(character);\n\n        if (this.status !== 'Playing')\n            return;\n\n        if (isUnique) {\n            this.guessesMade.push(character.toLowerCase());\n        }\n        if (isUnique && isBadGuess) {\n            this.remainingGuesses--;\n        }\n\n        this.recalculateStatus(this.correctWord, this.remainingGuesses, this.guessesMade);\n    }\n\n    recalculateStatus() {\n        let hasAllCorrect;\n\n        if (this.remainingGuesses === 0) {\n            this.status = 'Failed';\n        } else {\n            hasAllCorrect = this.correctWord.every((correctLetter) => {\n                return this.guessesMade.includes(correctLetter.toLowerCase()) || correctLetter === ' ';\n            });\n            this.status = hasAllCorrect ? 'Finished' : 'Playing';\n        }\n    }\n}\n\nexport { Hangman as default }","const getPuzzle = async (wordCound) => {\n    const response = await fetch(`https://puzzle.mead.io/puzzle?wordCount=${wordCound}`, {});\n\n    if (response.status === 200) {\n        const data = await response.json();\n        return data.puzzle;\n    } else {\n        throw new Error('Unable to fetch the puzzle')\n    }\n}\n\nconst getCountryDetails = async (countryCode) => {\n    const response = await fetch(`https://restcountries.com/v3.1/all`, {});\n\n    if (response.status === 200) {\n        const countries = await response.json();\n        return countries.find((country) => country.cca2 === countryCode);\n    } else {\n        throw new Error('Unable to fetch the country')\n    }\n}\n\nconst getLocationInformation = async () => {\n    const response = await fetch('https://ipinfo.io/json?token=9126880e9dd389', {});\n\n    if (response.status === 200)\n        return response.json();\n    else\n        throw new Error('Unable to fetch the location information')\n}\n\nconst getCurrentCountry = async () => {\n    const location = await getLocationInformation();\n    const country = await getCountryDetails(location.country);\n    return country;\n}\n\nexport { getPuzzle as default }","import Hangman from './hangman';\nimport getPuzzle from './http-requests-handler';\n\nconst remainingGuessesElement = document.querySelector('#remaining-guesses');\nconst gameStatus = document.querySelector('#game-status');\nconst wordElement = document.querySelector('#word');\nlet game1\n\nwindow.addEventListener('keypress', (e) => {\n    game1.makeGuess(e.key);\n    render();\n});\n\nconst render = () => {\n    gameStatus.textContent = game1.status;\n    remainingGuessesElement.textContent = game1.statusMessage;\n    wordElement.innerHTML = '';\n\n    let myPuzzleArray = Array.from(game1.puzzle);\n    myPuzzleArray.forEach((letter) => {\n        const letterElement = document.createElement('span');\n        letterElement.textContent = letter;\n        wordElement.append(letterElement);\n    })\n}\n\nconst startGame = async () => {\n    const puzzle = await getPuzzle(2);\n    game1 = new Hangman(puzzle, 8);\n    render();\n}\n\ndocument.querySelector('#reset-game').addEventListener('click', startGame);\n\nstartGame();\n"],"names":["Hangman","correctWord","remainingGuesses","this","split","guessesMade","status","puzzel","forEach","letter","includes","toLowerCase","join","character","isUnique","isBadGuess","push","recalculateStatus","hasAllCorrect","every","correctLetter","getPuzzle","wordCound","fetch","response","json","data","puzzle","Error","i","game1","remainingGuessesElement","document","querySelector","gameStatus","wordElement","window","addEventListener","e","makeGuess","key","render","textContent","statusMessage","innerHTML","Array","from","letterElement","createElement","append","startGame"],"sourceRoot":""}